<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Escape Moka Man</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; touch-action: none; }
        canvas { display: block; }
        .pixel-font { font-family: 'Courier New', Courier, monospace; font-weight: bold; }
        
        /* Shake animation for impact */
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        .shake { animation: shake 0.5s; }
    </style>
</head>
<body class="text-white select-none">

    <!-- UI Overlay -->
    <div id="ui-layer" class="absolute inset-0 pointer-events-none flex flex-col justify-between p-4 z-10">
        <div class="flex justify-between items-start">
            <div>
                <h1 class="text-2xl pixel-font text-yellow-500 drop-shadow-md">ESCAPE MOKA MAN</h1>
                <p class="text-sm text-gray-400">Avoid the Espresso Shots!</p>
                <div class="mt-2 flex items-center gap-2">
                    <span class="text-xs text-blue-300">DASH CHARGES:</span>
                    <div id="dash-ui" class="flex gap-1">
                        <!-- Dash pips generated by JS -->
                    </div>
                </div>
            </div>
            <div class="text-right">
                <div class="text-3xl pixel-font font-bold text-white" id="score-display">0</div>
                <div class="text-xs text-gray-400">SURVIVAL TIME</div>
            </div>
        </div>
        
        <!-- Controls Hint / Mobile Controls -->
        <div class="flex flex-col items-center justify-end h-full pb-8">
            <div class="text-center text-gray-500 text-sm opacity-50 mb-4 hidden md:block">
                Use ARROW KEYS / WASD to move ‚Ä¢ SPACE to Dash
            </div>
            <div class="md:hidden w-full flex justify-end px-4">
                <button id="mobile-dash-btn" class="pointer-events-auto bg-blue-600/50 hover:bg-blue-500/80 text-white font-bold p-6 rounded-full border-2 border-blue-300 shadow-lg active:scale-95 transition-all">
                    DASH
                </button>
            </div>
            <div class="text-center text-gray-500 text-sm opacity-50 mt-2 md:hidden">
                Touch & Drag to run
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="absolute inset-0 z-20 flex items-center justify-center bg-black/80 backdrop-blur-sm">
        <div class="text-center max-w-md p-6 border-4 border-yellow-700 bg-gray-900 rounded-lg shadow-2xl transform transition-all hover:scale-105">
            <h2 class="text-4xl text-yellow-500 mb-4 pixel-font tracking-tighter">MOKA MAN<br>AWAKENS</h2>
            <div class="w-24 h-24 mx-auto mb-4 bg-yellow-900/30 rounded-full flex items-center justify-center border-2 border-yellow-600">
                <svg viewBox="0 0 24 24" class="w-16 h-16 text-yellow-600" fill="currentColor">
                    <path d="M2,19H22V21H2V19M4,17H20V15H4V17M17,3H7A2,2 0 0,0 5,5V13H19V5A2,2 0 0,0 17,3M19,9H21V13H19V9M7,5H17V13H7V5Z" />
                </svg>
            </div>
            <p class="mb-6 text-gray-300">You are a Sugar Cube. <br>He wants to dissolve you in his coffee.</p>
            <div class="bg-gray-800 p-3 rounded mb-6 text-sm text-gray-400">
                <p class="text-blue-300 font-bold">NEW ABILITY: DASH</p>
                <p>Earn 1 Dash charge every 5 seconds.</p>
                <div class="mt-2 pt-2 border-t border-gray-700">
                    <p class="text-green-300 font-bold">POWER FART</p>
                    <p class="text-xs">Moka Man sometimes releases helpful gas clouds. Catch them for buffs!</p>
                </div>
            </div>
            <button id="start-btn" class="pointer-events-auto bg-yellow-600 hover:bg-yellow-500 text-black font-bold py-3 px-8 rounded shadow-[0_4px_0_rgb(113,63,18)] active:shadow-[0_0px_0_rgb(113,63,18)] active:translate-y-1 transition-all text-xl">
                RUN!
            </button>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="hidden absolute inset-0 z-20 flex items-center justify-center bg-red-900/90 backdrop-blur-sm">
        <div class="text-center max-w-md p-6">
            <h2 class="text-5xl text-white mb-2 pixel-font shake">DISSOLVED!</h2>
            <p class="text-xl text-yellow-200 mb-6">Moka Man caught you.</p>
            <div class="text-2xl mb-8 font-mono">Score: <span id="final-score">0</span></div>
            <button id="restart-btn" class="pointer-events-auto bg-white hover:bg-gray-200 text-red-900 font-bold py-3 px-8 rounded shadow-lg text-xl">
                TRY AGAIN
            </button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        const dashUi = document.getElementById('dash-ui');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreDisplay = document.getElementById('final-score');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const mobileDashBtn = document.getElementById('mobile-dash-btn');

        // Game State
        let gameRunning = false;
        let score = 0;
        let lastDashScore = 0;
        let frameCount = 0;
        let particles = [];
        let projectiles = [];
        let buffs = [];
        let floatingTexts = [];
        
        // Input State
        const keys = {
            ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
            w: false, s: false, a: false, d: false, W: false, S: false, A: false, D: false,
            ' ': false
        };
        
        const mouse = { x: 0, y: 0, isDown: false };

        // Resize handling
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // Input Listeners
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === ' ' && gameRunning) {
                player.tryDash();
            }
        });
        window.addEventListener('keyup', (e) => keys[e.key] = false);
        
        // Touch/Mouse Controls
        window.addEventListener('mousedown', (e) => {
            if(e.target.id !== 'mobile-dash-btn') {
                mouse.isDown = true;
                mouse.x = e.clientX;
                mouse.y = e.clientY;
            }
        });
        window.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });
        window.addEventListener('mouseup', () => mouse.isDown = false);
        
        window.addEventListener('touchstart', (e) => {
            if(e.target.id !== 'mobile-dash-btn') {
                mouse.isDown = true;
                mouse.x = e.touches[0].clientX;
                mouse.y = e.touches[0].clientY;
            }
        }, {passive: false});
        window.addEventListener('touchmove', (e) => {
            if(e.target.id !== 'mobile-dash-btn') {
                e.preventDefault(); 
                mouse.x = e.touches[0].clientX;
                mouse.y = e.touches[0].clientY;
            }
        }, {passive: false});
        window.addEventListener('touchend', () => mouse.isDown = false);

        mobileDashBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (gameRunning) player.tryDash();
        });
        mobileDashBtn.addEventListener('touchstart', (e) => {
            e.stopPropagation();
            if (gameRunning) player.tryDash();
        });


        // --- Game Entities ---

        class Player {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height / 2;
                this.size = 20;
                this.baseSpeed = 5;
                this.speedMultiplier = 1;
                this.speedBuffTimer = 0;
                this.color = '#ffffff'; // Sugar cube white
                
                // Dash Properties
                this.dashCharges = 1;
                this.maxDashCharges = 3;
                this.isDashing = false;
                this.dashTime = 0;
                this.dashDuration = 15;
                this.dashSpeed = 15;
                this.lastDirX = 1;
                this.lastDirY = 0;
            }

            addCharge() {
                if (this.dashCharges < this.maxDashCharges) {
                    this.dashCharges++;
                    createParticles(this.x, this.y, '#60A5FA', 5);
                }
            }

            applySpeedBuff(duration) {
                this.speedBuffTimer = duration;
                this.speedMultiplier = 2.0; // Double speed!
            }

            tryDash() {
                if (this.dashCharges > 0 && !this.isDashing) {
                    this.dashCharges--;
                    this.isDashing = true;
                    this.dashTime = this.dashDuration;
                    createParticles(this.x, this.y, '#FFFFFF', 10);
                }
            }

            update() {
                // Buff timers
                if (this.speedBuffTimer > 0) {
                    this.speedBuffTimer--;
                    if (this.speedBuffTimer <= 0) this.speedMultiplier = 1;
                }

                if (this.isDashing) {
                    this.x += this.lastDirX * this.dashSpeed;
                    this.y += this.lastDirY * this.dashSpeed;

                    if (frameCount % 3 === 0) {
                        particles.push(new Particle(this.x, this.y, 'rgba(255,255,255,0.5)', 3));
                    }

                    this.dashTime--;
                    if (this.dashTime <= 0) {
                        this.isDashing = false;
                    }
                } else {
                    let dx = 0;
                    let dy = 0;

                    if (keys.ArrowUp || keys.w || keys.W) dy = -1;
                    if (keys.ArrowDown || keys.s || keys.S) dy = 1;
                    if (keys.ArrowLeft || keys.a || keys.A) dx = -1;
                    if (keys.ArrowRight || keys.d || keys.D) dx = 1;

                    let currentSpeed = this.baseSpeed * this.speedMultiplier;

                    if (dx !== 0 || dy !== 0) {
                        const length = Math.sqrt(dx * dx + dy * dy);
                        dx /= length;
                        dy /= length;
                        this.lastDirX = dx;
                        this.lastDirY = dy;
                        this.x += dx * currentSpeed;
                        this.y += dy * currentSpeed;
                    } 
                    else if (mouse.isDown) {
                        const angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
                        const dist = Math.hypot(mouse.x - this.x, mouse.y - this.y);
                        
                        if (dist > 10) {
                            const moveX = Math.cos(angle);
                            const moveY = Math.sin(angle);
                            this.lastDirX = moveX;
                            this.lastDirY = moveY;
                            this.x += moveX * currentSpeed;
                            this.y += moveY * currentSpeed;
                        }
                    }
                }

                // Boundaries
                this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x));
                this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y));
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Sugar Cube Body
                let bodyColor = this.color;
                if (this.isDashing) bodyColor = '#93C5FD'; // Blue
                else if (this.speedBuffTimer > 0) bodyColor = '#86EFAC'; // Green

                ctx.fillStyle = bodyColor;
                ctx.shadowColor = this.isDashing ? '#3B82F6' : 'rgba(255, 255, 255, 0.5)';
                ctx.shadowBlur = this.isDashing ? 20 : 10;
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                
                // Cute scared face
                ctx.fillStyle = '#000';
                ctx.beginPath();
                if (this.isDashing) {
                     ctx.moveTo(-4, -2); ctx.lineTo(-2, -4);
                     ctx.moveTo(4, -2); ctx.lineTo(2, -4);
                } else {
                    ctx.arc(-4, -2, 2, 0, Math.PI * 2); 
                    ctx.arc(4, -2, 2, 0, Math.PI * 2); 
                }
                ctx.fill();
                
                // Mouth
                ctx.beginPath();
                if (this.isDashing) ctx.fillRect(-2, 4, 4, 2);
                else ctx.arc(0, 5, 3, 0, Math.PI * 2);
                ctx.fill();

                // Draw dash charges
                for(let i=0; i<this.maxDashCharges; i++) {
                    ctx.fillStyle = i < this.dashCharges ? '#3B82F6' : '#333';
                    const pipSize = 4;
                    const spacing = 6;
                    const startX = -((this.maxDashCharges * spacing) / 2) + spacing/2;
                    ctx.fillRect(startX + (i * spacing) - pipSize/2, -20, pipSize, pipSize);
                }

                ctx.restore();
            }
        }

        class MokaMan {
            constructor() {
                this.x = -100;
                this.y = canvas.height / 2;
                this.size = 80;
                this.baseSpeed = 2;
                this.speed = this.baseSpeed;
                this.angle = 0;
                this.phase = 'chase'; // chase, charge, shoot, spin-charge, spin-fire
                this.phaseTimer = 0;
                this.spinAngle = 0; // For spin animation
                
                // Mechanics
                this.stunTimer = 0;
                this.fartTimer = 300; 
            }

            stun(duration) {
                this.stunTimer = duration;
                // Visual feedback for stun
                createParticles(this.x, this.y, '#FCD34D', 15);
                floatingTexts.push(new FloatingText(this.x, this.y - 50, "STUNNED!", "#FCD34D"));
            }

            update(player) {
                if (this.stunTimer > 0) {
                    this.stunTimer--;
                    // Vibration effect while stunned
                    this.x += (Math.random() - 0.5) * 2;
                    this.y += (Math.random() - 0.5) * 2;
                    return; // Skip normal movement
                }

                // Fart Buff Logic
                this.fartTimer--;
                if (this.fartTimer <= 0) {
                    this.fartTimer = Math.random() * 400 + 400; // Random interval 7-14s
                    this.fart();
                }

                // Difficulty scaling
                this.speed = this.baseSpeed + (score / 40); 
                this.speed = Math.min(this.speed, player.baseSpeed * 1.3);

                // Calculate angle to player (but don't apply it yet)
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const angleToPlayer = Math.atan2(dy, dx);

                // AI State Machine
                this.phaseTimer++;

                if (this.phase === 'chase') {
                    this.angle = angleToPlayer; // Track player constantly
                    this.x += Math.cos(this.angle) * this.speed;
                    this.y += Math.sin(this.angle) * this.speed;

                    // Decision Making
                    const actionChance = 0.02 + (score * 0.0005);
                    
                    if (this.phaseTimer > 100 && Math.random() < actionChance) {
                        const rand = Math.random();
                        
                        if (rand < 0.35) {
                            // Charge
                            this.phase = 'charge';
                            this.phaseTimer = 0;
                            createParticles(this.x, this.y, 'orange', 10);
                        } else if (rand < 0.65) {
                            // NEW: Spin Attack
                            this.phase = 'spin-charge';
                            this.phaseTimer = 0;
                            floatingTexts.push(new FloatingText(this.x, this.y - 60, "SPIN!", "#FFF"));
                        } else {
                            // Shoot (Single or Triple)
                            if (Math.random() < 0.4) {
                                this.tripleShoot(player);
                            } else {
                                this.shoot(player);
                            }
                        }
                    }

                } else if (this.phase === 'charge') {
                    if (this.phaseTimer < 60) {
                        // Warning phase - Keep tracking player so he aims
                        this.angle = angleToPlayer;
                        // Shake
                        this.x += (Math.random() - 0.5) * 4;
                        this.y += (Math.random() - 0.5) * 4;
                    } else if (this.phaseTimer < 90) {
                        // DASH PHASE: Straight line dash (angle locked from previous phase)
                        const dashMult = 8 + (score / 100);
                        this.x += Math.cos(this.angle) * (this.speed * dashMult);
                        this.y += Math.sin(this.angle) * (this.speed * dashMult);
                    } else {
                        this.phase = 'chase';
                        this.phaseTimer = 0;
                    }
                } else if (this.phase === 'spin-charge') {
                    // Telegraphing: Spin rapidly in place
                    this.spinAngle += 0.4;
                    
                    // Suck in particles effect (White/Steam)
                    if (frameCount % 4 === 0) {
                        const range = 60;
                        const px = this.x + (Math.random()-0.5) * range * 2;
                        const py = this.y + (Math.random()-0.5) * range * 2;
                        // Particle moving towards center
                        const angleToCenter = Math.atan2(this.y - py, this.x - px);
                        const p = new Particle(px, py, '#D7CCC8', 4);
                        p.vx = Math.cos(angleToCenter) * 4;
                        p.vy = Math.sin(angleToCenter) * 4;
                        p.life = 0.5; // Short life
                        particles.push(p);
                    }

                    if (this.phaseTimer > 50) { // ~0.8s warning
                        this.phase = 'spin-fire';
                    }

                } else if (this.phase === 'spin-fire') {
                    this.spinAttack();
                    this.phase = 'chase';
                    this.phaseTimer = 0;
                    this.spinAngle = 0; // Reset spin
                }
            }

            fart() {
                const backAngle = this.angle + Math.PI;
                const spawnX = this.x + Math.cos(backAngle) * 40;
                const spawnY = this.y + Math.sin(backAngle) * 40;
                const types = ['SPEED', 'DASH', 'STUN'];
                const type = types[Math.floor(Math.random() * types.length)];
                buffs.push(new Buff(spawnX, spawnY, type));
                createParticles(spawnX, spawnY, '#795548', 20);
                floatingTexts.push(new FloatingText(spawnX, spawnY, "POOF!", "#A1887F"));
            }

            shoot(player) {
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                const projSpeed = 8 + (score / 50);
                projectiles.push(new Projectile(this.x, this.y, angle, projSpeed));
            }

            tripleShoot(player) {
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                const projSpeed = 7 + (score / 50); // Slightly slower for spread
                const spread = 0.4; // Radians
                
                projectiles.push(new Projectile(this.x, this.y, angle, projSpeed));
                projectiles.push(new Projectile(this.x, this.y, angle - spread, projSpeed));
                projectiles.push(new Projectile(this.x, this.y, angle + spread, projSpeed));
                
                // Visual
                floatingTexts.push(new FloatingText(this.x, this.y - 50, "TRIPLE!", "#ffaa00"));
            }

            spinAttack() {
                const count = 12;
                const speed = 6 + (score / 60);
                for(let i=0; i<count; i++) {
                    const angle = (Math.PI * 2 / count) * i;
                    projectiles.push(new Projectile(this.x, this.y, angle, speed));
                }
                // Shockwave particles
                createParticles(this.x, this.y, '#3E2723', 30);
                // Screen shake
                // (Optional: triggers a CSS shake class on canvas container if we had one, but we use canvas offset usually)
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Rotation handling
                if (this.phase === 'spin-charge') {
                    ctx.rotate(this.spinAngle);
                } else if (this.stunTimer > 0) {
                    ctx.rotate((Math.random()-0.5) * 0.1);
                } else {
                    const tilt = Math.max(-0.2, Math.min(0.2, Math.cos(this.angle)));
                    ctx.rotate(tilt);
                }
                
                const scale = 1.2;
                ctx.scale(scale, scale);

                // 1. Cape
                ctx.fillStyle = '#3E2723';
                ctx.beginPath();
                ctx.moveTo(-20, -40); ctx.lineTo(20, -40); ctx.lineTo(30, 60); ctx.lineTo(-30, 60);
                ctx.fill();

                // 2. Body Armor
                const grad = ctx.createLinearGradient(-30, -50, 30, 50);
                grad.addColorStop(0, '#8D6E63');
                grad.addColorStop(0.5, '#D7CCC8'); 
                grad.addColorStop(1, '#5D4037');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.moveTo(-25, -30); ctx.lineTo(25, -30); ctx.lineTo(20, 40); ctx.lineTo(-20, 40);
                ctx.closePath();
                ctx.fill();
                ctx.lineWidth = 2; ctx.strokeStyle = '#3E2723'; ctx.stroke();

                // 3. Chest Logo
                ctx.fillStyle = '#3E2723';
                ctx.beginPath();
                ctx.moveTo(-8, -10); ctx.lineTo(8, -10); ctx.lineTo(10, 5); ctx.lineTo(-10, 5);
                ctx.fill();
                
                // 4. Head
                ctx.save();
                ctx.translate(0, -50);
                // Handle
                ctx.strokeStyle = '#4E342E'; ctx.lineWidth = 6;
                ctx.beginPath(); ctx.moveTo(25, 0); ctx.bezierCurveTo(45, 0, 45, 30, 25, 35); ctx.stroke();
                // Pot
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.moveTo(-20, -25); ctx.lineTo(20, -25); ctx.lineTo(25, 30); ctx.lineTo(-25, 30); ctx.closePath();
                ctx.fill(); ctx.stroke();
                // Knob
                ctx.fillStyle = '#3E2723'; ctx.fillRect(-5, -35, 10, 10);
                // Visor
                ctx.fillStyle = '#3E2723';
                ctx.beginPath(); ctx.moveTo(-20, -5); ctx.lineTo(20, -5); ctx.lineTo(15, 10); ctx.lineTo(0, 5); ctx.lineTo(-15, 10); ctx.fill();
                // Eyes (Blue if stunned, else Yellow)
                ctx.fillStyle = this.stunTimer > 0 ? '#60A5FA' : '#FFECB3';
                ctx.beginPath(); ctx.arc(-10, 0, 3, 0, Math.PI*2); ctx.arc(10, 0, 3, 0, Math.PI*2); ctx.fill();
                ctx.restore();

                // 5. Arms
                ctx.fillStyle = grad;
                // Spin animation: Arms out
                if (this.phase === 'spin-charge') {
                     ctx.beginPath(); ctx.arc(-40, -10, 12, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                     ctx.beginPath(); ctx.arc(40, -10, 12, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                } else {
                    const armSwing = Math.sin(Date.now() / 100) * 10;
                    ctx.beginPath(); ctx.arc(-35, -20 + armSwing, 12, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                    ctx.beginPath(); ctx.arc(35, -20 - armSwing, 12, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                }

                ctx.restore();
            }
        }

        class Buff {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type; // SPEED, DASH, STUN
                this.radius = 15;
                this.life = 600; // 10 seconds duration on floor
                
                // Config
                if (type === 'SPEED') {
                    this.color = '#4ADE80'; // Green
                    this.label = '‚ö°';
                } else if (type === 'DASH') {
                    this.color = '#60A5FA'; // Blue
                    this.label = '‚è©';
                } else if (type === 'STUN') {
                    this.color = '#FCD34D'; // Yellow
                    this.label = 'üí´';
                }
            }

            update() {
                this.life--;
            }

            draw() {
                // Pulsing effect
                const pulse = Math.sin(Date.now() / 200) * 3;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Bubble background
                ctx.globalAlpha = 0.6 + (Math.sin(Date.now() / 100) * 0.2);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius + pulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Border
                ctx.globalAlpha = 1.0;
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Icon
                ctx.fillStyle = '#fff';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.label, 0, 1); // +1 y adjustment

                ctx.restore();
            }
        }

        class Projectile {
            constructor(x, y, angle, speed) {
                this.x = x;
                this.y = y;
                this.radius = 6;
                this.speed = speed || 8;
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
                this.color = '#3e2723'; 
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                if (Math.random() < 0.3) {
                    particles.push(new Particle(this.x, this.y, '#6D4C41', 2));
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
            }
        }

        class Particle {
            constructor(x, y, color, sizeBase) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * sizeBase + 1;
                this.color = color;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.life = 1.0; 
                this.decay = Math.random() * 0.05 + 0.02;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
            }
            
            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class FloatingText {
            constructor(x, y, text, color) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.color = color;
                this.life = 60;
                this.dy = -1;
            }
            update() {
                this.y += this.dy;
                this.life--;
            }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life / 20);
                ctx.fillStyle = this.color;
                ctx.font = 'bold 20px Courier New';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                ctx.strokeText(this.text, this.x, this.y);
                ctx.fillText(this.text, this.x, this.y);
                ctx.globalAlpha = 1.0;
            }
        }

        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color, 5));
            }
        }

        function updateUI() {
            dashUi.innerHTML = '';
            for(let i=0; i < player.maxDashCharges; i++) {
                const pip = document.createElement('div');
                pip.className = `w-3 h-3 rounded-full ${i < player.dashCharges ? 'bg-blue-500 shadow-[0_0_8px_rgba(59,130,246,0.8)]' : 'bg-gray-700'}`;
                dashUi.appendChild(pip);
            }
            scoreDisplay.innerText = score;
        }

        // --- Game Loop ---

        function initGame() {
            player = new Player();
            mokaMan = new MokaMan();
            score = 0;
            lastDashScore = 0;
            frameCount = 0;
            particles = [];
            projectiles = [];
            buffs = [];
            floatingTexts = [];
            updateUI();
            
            mokaMan.x = -100;
            mokaMan.y = canvas.height / 2;
        }

        function gameOver() {
            gameRunning = false;
            cancelAnimationFrame(gameLoopId);
            finalScoreDisplay.innerText = score;
            gameOverScreen.classList.remove('hidden');
        }

        function checkCollisions() {
            // Boss
            const distBoss = Math.hypot(player.x - mokaMan.x, player.y - mokaMan.y);
            if (distBoss < player.size + mokaMan.size * 0.5 && mokaMan.stunTimer <= 0) { 
                gameOver();
            }
            // Projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                const distProj = Math.hypot(player.x - p.x, player.y - p.y);
                if (distProj < player.size + p.radius) {
                    gameOver();
                }
            }
            // Buffs
            for (let i = buffs.length - 1; i >= 0; i--) {
                const b = buffs[i];
                const dist = Math.hypot(player.x - b.x, player.y - b.y);
                if (dist < player.size + b.radius) {
                    // Collect Buff
                    if (b.type === 'SPEED') {
                        player.applySpeedBuff(300); // 5 seconds
                        floatingTexts.push(new FloatingText(player.x, player.y, "SPEED UP!", "#4ADE80"));
                    } else if (b.type === 'DASH') {
                        player.dashCharges = Math.min(player.maxDashCharges + 2, player.dashCharges + 1); // Can overcharge slightly
                        updateUI();
                        floatingTexts.push(new FloatingText(player.x, player.y, "+1 DASH", "#60A5FA"));
                    } else if (b.type === 'STUN') {
                        mokaMan.stun(180); // 3 seconds
                        floatingTexts.push(new FloatingText(player.x, player.y, "STUNNED!", "#FCD34D"));
                    }
                    createParticles(b.x, b.y, b.color, 10);
                    buffs.splice(i, 1);
                }
            }
        }

        function update() {
            if (!gameRunning) return;

            // Clear Canvas
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Grid
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 1;
            const gridSize = 50;
            ctx.beginPath();
            for(let x=0; x<=canvas.width; x+=gridSize) { ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); }
            for(let y=0; y<=canvas.height; y+=gridSize) { ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); }
            ctx.stroke();

            // Entity Updates
            player.update();
            mokaMan.update(player);

            // Buffs
            for (let i = buffs.length - 1; i >= 0; i--) {
                buffs[i].update();
                if (buffs[i].life <= 0) buffs.splice(i, 1);
            }

            // Projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                projectiles[i].update();
                if (projectiles[i].x < 0 || projectiles[i].x > canvas.width || 
                    projectiles[i].y < 0 || projectiles[i].y > canvas.height) {
                    projectiles.splice(i, 1);
                }
            }

            // Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                if (particles[i].life <= 0) particles.splice(i, 1);
            }

            // Floating Text
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                floatingTexts[i].update();
                floatingTexts[i].draw();
                if (floatingTexts[i].life <= 0) floatingTexts.splice(i, 1);
            }

            checkCollisions();

            // Draw Layering
            buffs.forEach(b => b.draw());
            particles.forEach(p => p.draw());
            projectiles.forEach(p => p.draw());
            mokaMan.draw(); // Draw boss behind player maybe? No, boss on top usually dangerous
            player.draw();

            // Score Logic
            if (frameCount % 60 === 0 && frameCount > 0) {
                score++;
                if (score % 5 === 0 && score !== lastDashScore) {
                    player.addCharge();
                    lastDashScore = score;
                }
                updateUI();
            }
            frameCount++;

            gameLoopId = requestAnimationFrame(update);
        }

        // Start Handlers
        startBtn.addEventListener('click', () => {
            startScreen.classList.add('hidden');
            gameRunning = true;
            initGame();
            update();
        });

        restartBtn.addEventListener('click', () => {
            gameOverScreen.classList.add('hidden');
            gameRunning = true;
            initGame();
            update();
        });

        // Initial Draw
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

    </script>
</body>
</html>
