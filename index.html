<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Escape Moka Man: Ultimate</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; touch-action: none; user-select: none; -webkit-user-select: none; }
        canvas { display: block; }
        .pixel-font { font-family: 'Courier New', Courier, monospace; font-weight: bold; }
        
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        .shake { animation: shake 0.5s; }
        
        .boss-hit-flash { animation: flashRed 0.1s; }
        
        /* Laser glow effect */
        .laser-glow {
            box-shadow: 0 0 10px #d946ef, 0 0 20px #d946ef, 0 0 30px #d946ef;
        }
    </style>
</head>
<body class="text-white select-none">

    <!-- UI Overlay -->
    <div id="ui-layer" class="absolute inset-0 pointer-events-none flex flex-col justify-between p-4 z-10">
        
        <!-- Top UI: Boss Health & Score -->
        <div class="w-full flex flex-col items-center">
            <!-- Boss Health Bar Container (Hidden in Classic) -->
            <div id="boss-ui" class="w-full max-w-2xl mb-2 hidden">
                <div class="flex justify-between text-xs text-red-400 font-bold mb-1 uppercase tracking-widest">
                    <span id="boss-name">Moka Man</span>
                    <span>Rage Level: <span id="rage-level">1</span></span>
                </div>
                <div class="w-full h-6 bg-gray-900 border-2 border-red-900 rounded-sm relative overflow-hidden">
                    <div id="boss-hp-bar" class="h-full bg-gradient-to-r from-red-600 to-red-500 transition-all duration-200" style="width: 100%"></div>
                </div>
            </div>

            <div class="flex justify-between w-full items-start">
                <div>
                    <!-- Player Stats UI -->
                    <div class="flex flex-col gap-1">
                        <!-- Lives -->
                        <div id="lives-container" class="flex items-center gap-2">
                            <span class="text-xs text-red-400 w-12 font-bold">LIVES:</span>
                            <div id="lives-ui" class="flex gap-1 text-red-500 text-lg">â™¥</div>
                        </div>
                        <!-- Ammo -->
                        <div id="ammo-container" class="flex items-center gap-2">
                            <span class="text-xs text-yellow-400 w-12 font-bold">AMMO:</span>
                            <span id="ammo-ui" class="text-yellow-400 font-mono font-bold text-lg">67</span>
                        </div>
                        <!-- Dash -->
                        <div class="flex items-center gap-2">
                            <span class="text-xs text-blue-300 w-12 font-bold">DASH:</span>
                            <div id="dash-ui" class="flex gap-1"></div>
                        </div>
                        <!-- Laser Timer -->
                        <div id="laser-ui-container" class="hidden items-center gap-2">
                            <span class="text-xs text-purple-400 w-12 font-bold">LASER:</span>
                            <div class="w-24 h-2 bg-gray-800 rounded">
                                <div id="laser-bar" class="h-full bg-purple-500"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="text-right">
                    <div class="text-3xl pixel-font font-bold text-white" id="score-display">0</div>
                    <div class="text-xs text-gray-400">SCORE</div>
                </div>
            </div>
        </div>
        
        <!-- Controls Hint / Mobile Controls -->
        <div class="flex flex-col items-center justify-end h-full pb-8">
            <div id="controls-hint" class="text-center text-gray-500 text-sm opacity-50 mb-4 hidden md:block">
                WASD/ARROWS to Move â€¢ CLICK to Shoot â€¢ SPACE to Dash
            </div>
            
            <!-- Mobile Controls -->
            <div class="md:hidden w-full flex justify-between px-4 gap-4">
                <button id="mobile-shoot-btn" class="pointer-events-auto bg-red-600/50 hover:bg-red-500/80 text-white font-bold p-6 rounded-2xl border-2 border-red-300 shadow-lg active:scale-95 transition-all w-1/2">
                    SHOOT
                </button>
                <button id="mobile-dash-btn" class="pointer-events-auto bg-blue-600/50 hover:bg-blue-500/80 text-white font-bold p-6 rounded-2xl border-2 border-blue-300 shadow-lg active:scale-95 transition-all w-1/2">
                    DASH
                </button>
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="absolute inset-0 z-20 flex items-center justify-center bg-black/80 backdrop-blur-sm">
        <div class="text-center max-w-lg p-6 border-4 border-yellow-700 bg-gray-900 rounded-lg shadow-2xl transform transition-all">
            <h2 class="text-4xl text-yellow-500 mb-2 pixel-font tracking-tighter">MOKA MAN<br>ULTIMATE</h2>
            <div class="w-20 h-20 mx-auto mb-4 bg-yellow-900/30 rounded-full flex items-center justify-center border-2 border-yellow-600">
                <svg viewBox="0 0 24 24" class="w-12 h-12 text-yellow-600" fill="currentColor">
                    <path d="M2,19H22V21H2V19M4,17H20V15H4V17M17,3H7A2,2 0 0,0 5,5V13H19V5A2,2 0 0,0 17,3M19,9H21V13H19V9M7,5H17V13H7V5Z" />
                </svg>
            </div>
            <p class="mb-6 text-gray-300 text-sm">You are a Sugar Cube. Run or Fight.</p>
            
            <div class="grid grid-cols-2 gap-4">
                <!-- Classic Mode -->
                <button id="btn-classic" class="pointer-events-auto group bg-gray-800 hover:bg-gray-700 border-2 border-gray-600 hover:border-blue-400 p-4 rounded transition-all">
                    <div class="text-blue-400 font-bold text-xl mb-1">CLASSIC</div>
                    <div class="text-xs text-gray-400">Survive as long as possible.<br>No Shooting. One Life.</div>
                </button>

                <!-- Boss Mode -->
                <button id="btn-boss" class="pointer-events-auto group bg-gray-800 hover:bg-gray-700 border-2 border-gray-600 hover:border-red-400 p-4 rounded transition-all">
                    <div class="text-red-400 font-bold text-xl mb-1">BOSS FIGHT</div>
                    <div class="text-xs text-gray-400">Kill Moka Man.<br>Guns, Lazers, Ammo & Lives.</div>
                </button>
            </div>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="hidden absolute inset-0 z-20 flex items-center justify-center bg-red-900/90 backdrop-blur-sm">
        <div class="text-center max-w-md p-6">
            <h2 class="text-5xl text-white mb-2 pixel-font shake">GAME OVER</h2>
            <p class="text-xl text-yellow-200 mb-6" id="death-msg">Moka Man caught you.</p>
            <div class="text-2xl mb-4 font-mono">Score: <span id="final-score">0</span></div>
            <div id="boss-stats-end" class="text-lg mb-8 text-red-300">Rage Reached: <span id="final-rage">0</span></div>
            <button id="restart-btn" class="pointer-events-auto bg-white hover:bg-gray-200 text-red-900 font-bold py-3 px-8 rounded shadow-lg text-xl">
                TRY AGAIN
            </button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // UI Elements
        const scoreDisplay = document.getElementById('score-display');
        const dashUi = document.getElementById('dash-ui');
        const livesUi = document.getElementById('lives-ui');
        const ammoUi = document.getElementById('ammo-ui');
        const livesContainer = document.getElementById('lives-container');
        const ammoContainer = document.getElementById('ammo-container');
        const laserUiContainer = document.getElementById('laser-ui-container');
        const laserBar = document.getElementById('laser-bar');
        const controlsHint = document.getElementById('controls-hint');
        
        const bossUi = document.getElementById('boss-ui');
        const bossHpBar = document.getElementById('boss-hp-bar');
        const rageLevelDisplay = document.getElementById('rage-level');
        
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreDisplay = document.getElementById('final-score');
        const finalRageDisplay = document.getElementById('final-rage');
        const bossStatsEnd = document.getElementById('boss-stats-end');
        
        const btnClassic = document.getElementById('btn-classic');
        const btnBoss = document.getElementById('btn-boss');
        const restartBtn = document.getElementById('restart-btn');
        const mobileDashBtn = document.getElementById('mobile-dash-btn');
        const mobileShootBtn = document.getElementById('mobile-shoot-btn');

        // Game State
        let gameRunning = false;
        let gameMode = 'BOSS'; // 'CLASSIC' or 'BOSS'
        let score = 0;
        let frameCount = 0;
        
        let particles = [];
        let projectiles = []; 
        let bullets = []; 
        let buffs = [];
        let floatingTexts = [];
        
        // Input
        const keys = {};
        const mouse = { x: 0, y: 0, isDown: false };

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // Controls
        window.addEventListener('keydown', (e) => {
            if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();
            keys[e.key] = true;
            if (e.key === ' ' && gameRunning && player) player.tryDash();
        });
        window.addEventListener('keyup', (e) => keys[e.key] = false);
        
        window.addEventListener('mousedown', (e) => {
            if (e.target.tagName !== 'BUTTON') {
                mouse.isDown = true;
                mouse.x = e.clientX;
                mouse.y = e.clientY;
                if (gameRunning && gameMode === 'BOSS' && player && !player.hasLaser) {
                    player.shoot(e.clientX, e.clientY);
                }
            }
        });
        window.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });
        window.addEventListener('mouseup', () => mouse.isDown = false);
        
        // Touch
        const handleTouchMove = (e) => {
            if (e.target.tagName !== 'BUTTON') {
                e.preventDefault();
                mouse.x = e.touches[0].clientX;
                mouse.y = e.touches[0].clientY;
                mouse.isDown = true;
            }
        };
        window.addEventListener('touchstart', handleTouchMove, {passive: false});
        window.addEventListener('touchmove', handleTouchMove, {passive: false});
        window.addEventListener('touchend', () => mouse.isDown = false);

        mobileDashBtn.addEventListener('touchstart', (e) => { 
            e.stopPropagation(); 
            if (gameRunning && player) player.tryDash(); 
        });
        mobileShootBtn.addEventListener('touchstart', (e) => { 
            e.stopPropagation(); 
            if (gameRunning && gameMode === 'BOSS' && player) player.shoot(mokaMan.x, mokaMan.y); 
        });

        // --- ENTITIES ---

        class Player {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height / 2;
                this.size = 20;
                this.baseSpeed = 5; 
                this.speedMultiplier = 1;
                this.speedBuffTimer = 0;
                this.color = '#ffffff';
                
                // Survival
                this.lives = 1;
                this.maxLives = 3;
                this.invulnerableTimer = 0;
                
                // Combat
                this.ammo = 67;
                this.shootCooldown = 0;
                this.hasLaser = false;
                this.laserTimer = 0;
                this.laserMaxTime = 180; // Nerfed: 5s -> 3s (180 frames)

                // Dash
                this.dashCharges = 1;
                this.maxDashCharges = 3;
                this.isDashing = false;
                this.dashTime = 0;
                this.dashDuration = 10;
                this.dashSpeed = 18;
                this.lastDirX = 0;
                this.lastDirY = 0;
                
                // Dash Regen
                this.dashRegenTimer = 0;
                this.dashRegenThreshold = 300; // Frames to regen one charge
            }

            addLife() {
                if (this.lives < this.maxLives) {
                    this.lives++;
                    floatingTexts.push(new FloatingText(this.x, this.y - 20, "+1 LIFE!", "#ff3333"));
                }
            }

            activateLaser() {
                this.hasLaser = true;
                this.laserTimer = this.laserMaxTime;
                floatingTexts.push(new FloatingText(this.x, this.y - 40, "LASER ACTIVE!", "#d946ef"));
            }

            takeDamage() {
                if (this.invulnerableTimer > 0) return false;
                
                this.lives--;
                this.invulnerableTimer = 120;
                createParticles(this.x, this.y, '#ff0000', 15);
                updateUI();
                
                return this.lives <= 0;
            }

            addAmmo(amount) {
                this.ammo += amount;
                floatingTexts.push(new FloatingText(this.x, this.y - 20, `+${amount} AMMO`, "#FFD700"));
                updateUI();
            }

            applySpeedBuff(duration) {
                this.speedBuffTimer = duration;
                this.speedMultiplier = 1.8;
            }

            tryDash() {
                if (this.dashCharges > 0 && !this.isDashing) {
                    this.dashCharges--;
                    this.isDashing = true;
                    this.dashTime = this.dashDuration;
                    
                    if (this.lastDirX === 0 && this.lastDirY === 0) {
                         const angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
                         this.lastDirX = Math.cos(angle);
                         this.lastDirY = Math.sin(angle);
                    }
                    createParticles(this.x, this.y, '#FFFFFF', 10);
                    updateUI(); // Immediate UI update for dash usage
                }
            }

            shoot(targetX, targetY) {
                if (this.shootCooldown > 0 || this.hasLaser) return;
                
                if (this.ammo <= 0) {
                    floatingTexts.push(new FloatingText(this.x, this.y, "NO AMMO!", "#555"));
                    return;
                }

                this.ammo--;
                updateUI();

                const angle = Math.atan2(targetY - this.y, targetX - this.x);
                bullets.push(new Bullet(this.x, this.y, angle));
                this.shootCooldown = 15; 
                this.x -= Math.cos(angle) * 2;
                this.y -= Math.sin(angle) * 2;
            }

            fireLaser() {
                if (this.laserTimer > 0) {
                    const angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
                    const range = 800;
                    const endX = this.x + Math.cos(angle) * range;
                    const endY = this.y + Math.sin(angle) * range;

                    // Draw Laser
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = '#d946ef';
                    ctx.lineWidth = 6 + Math.sin(frameCount * 0.5) * 2;
                    ctx.lineCap = 'round';
                    ctx.shadowColor = '#f0abfc';
                    ctx.shadowBlur = 15;
                    ctx.stroke();
                    ctx.restore();
                    
                    // Laser Damage to Boss (Ray vs Circle Logic)
                    // Simplified: Check if Boss is near the line
                    // Project Boss center onto line
                    const bx = mokaMan.x, by = mokaMan.y;
                    const A = this.x - bx;
                    const B = this.y - by;
                    const C = endX - this.x;
                    const D = endY - this.y;

                    const dot = - (A * C + B * D);
                    const lenSq = C * C + D * D;
                    let param = -1;
                    if (lenSq !== 0) param = dot / lenSq;

                    let xx, yy;

                    if (param < 0) { xx = this.x; yy = this.y; }
                    else if (param > 1) { xx = endX; yy = endY; }
                    else { xx = this.x + param * C; yy = this.y + param * D; }

                    const dist = Math.hypot(bx - xx, by - yy);
                    if (dist < mokaMan.size * 0.8) {
                        mokaMan.takeDamage(0.5); // Nerfed: 1.5 -> 0.5 damage per tick
                        createParticles(xx, yy, '#d946ef', 1);
                    }
                    
                    // Destroy Projectiles with Laser
                    for(let i = projectiles.length - 1; i >= 0; i--) {
                        const p = projectiles[i];
                        const pA = this.x - p.x;
                        const pB = this.y - p.y;
                        const pDot = - (pA * C + pB * D);
                        let pParam = -1;
                        if(lenSq !== 0) pParam = pDot / lenSq;
                        
                        let px, py;
                        if (pParam < 0) { px = this.x; py = this.y; }
                        else if (pParam > 1) { px = endX; py = endY; }
                        else { px = this.x + pParam * C; py = this.y + pParam * D; }
                        
                        if (Math.hypot(p.x - px, p.y - py) < p.radius + 10) {
                            projectiles.splice(i, 1);
                            createParticles(px, py, '#ffa500', 3);
                        }
                    }

                    this.laserTimer--;
                    if (this.laserTimer <= 0) {
                        this.hasLaser = false;
                        floatingTexts.push(new FloatingText(this.x, this.y, "LASER DEPLETED", "#555"));
                    }
                }
            }

            update() {
                if (this.shootCooldown > 0) this.shootCooldown--;
                if (this.speedBuffTimer > 0) this.speedBuffTimer--; else this.speedMultiplier = 1;
                if (this.invulnerableTimer > 0) this.invulnerableTimer--;

                // Dash Regen Logic
                // Base 300 frames (5s). Reduces by 30 frames per Rage Level (Boss) or per 10 Score (Classic)
                let regenReduction = 0;
                if (gameMode === 'BOSS') regenReduction = mokaMan.rageLevel * 40;
                else regenReduction = Math.min(200, score * 5);
                
                const currentRegenThreshold = Math.max(60, this.dashRegenThreshold - regenReduction);
                
                this.dashRegenTimer++;
                if (this.dashRegenTimer >= currentRegenThreshold) {
                    if (this.dashCharges < this.maxDashCharges) {
                        // FIX: Ensure UI is updated correctly if method is called here
                        // Actually addCharge handles UI? No, addCharge is internal to Player mostly?
                        // Player.addCharge() calls createParticles, but updateUI needs to be called.
                        this.addCharge();
                        updateUI();
                    }
                    this.dashRegenTimer = 0;
                }

                if (this.isDashing) {
                    this.x += this.lastDirX * this.dashSpeed;
                    this.y += this.lastDirY * this.dashSpeed;
                    if (frameCount % 2 === 0) particles.push(new Particle(this.x, this.y, 'rgba(255,255,255,0.5)', 3));
                    this.dashTime--;
                    if (this.dashTime <= 0) this.isDashing = false;
                } else {
                    let dx = 0; let dy = 0;
                    if (keys.ArrowUp || keys.w || keys.W) dy -= 1;
                    if (keys.ArrowDown || keys.s || keys.S) dy += 1;
                    if (keys.ArrowLeft || keys.a || keys.A) dx -= 1;
                    if (keys.ArrowRight || keys.d || keys.D) dx += 1;

                    let moveSpeed = this.baseSpeed * this.speedMultiplier;

                    if (dx !== 0 || dy !== 0) {
                        const len = Math.sqrt(dx*dx + dy*dy);
                        this.lastDirX = dx/len;
                        this.lastDirY = dy/len;
                        this.x += this.lastDirX * moveSpeed;
                        this.y += this.lastDirY * moveSpeed;
                    } else if (mouse.isDown && !this.hasLaser) {
                         // Drag move
                        const angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
                        const dist = Math.hypot(mouse.x - this.x, mouse.y - this.y);
                        if (dist > 10) {
                            this.lastDirX = Math.cos(angle);
                            this.lastDirY = Math.sin(angle);
                            this.x += this.lastDirX * moveSpeed;
                            this.y += this.lastDirY * moveSpeed;
                        }
                    }
                }
                
                if (this.hasLaser && mouse.isDown) {
                    this.fireLaser();
                }

                this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x));
                this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y));
            }

            // ADDED addCharge helper here to fix scope if it was missing or ensure particles
            addCharge() {
                if (this.dashCharges < this.maxDashCharges) {
                    this.dashCharges++;
                    createParticles(this.x, this.y, '#60A5FA', 5);
                }
            }

            draw() {
                if (this.invulnerableTimer > 0 && Math.floor(Date.now() / 50) % 2 === 0) return;

                ctx.save();
                ctx.translate(this.x, this.y);
                
                let bodyColor = this.color;
                if (this.isDashing) bodyColor = '#93C5FD';
                else if (this.speedBuffTimer > 0) bodyColor = '#86EFAC';
                else if (this.hasLaser) bodyColor = '#d946ef';

                ctx.fillStyle = bodyColor;
                ctx.shadowColor = this.hasLaser ? '#d946ef' : (this.isDashing ? '#3B82F6' : 'rgba(255, 255, 255, 0.5)');
                ctx.shadowBlur = 10;
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                
                // Laser Gun Visual
                if (this.hasLaser) {
                    const angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
                    ctx.save();
                    ctx.rotate(angle);
                    ctx.fillStyle = '#a21caf';
                    ctx.fillRect(5, -3, 15, 6);
                    ctx.restore();
                }

                // Face
                ctx.fillStyle = '#000';
                ctx.beginPath();
                if (this.isDashing) {
                     ctx.moveTo(-4, -2); ctx.lineTo(-2, -4);
                     ctx.moveTo(4, -2); ctx.lineTo(2, -4);
                } else {
                    ctx.arc(-4, -2, 2, 0, Math.PI * 2); 
                    ctx.arc(4, -2, 2, 0, Math.PI * 2); 
                }
                ctx.fill();
                ctx.beginPath();
                if (this.isDashing) ctx.fillRect(-2, 4, 4, 2);
                else ctx.arc(0, 5, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Dash Charges
                for(let i=0; i<this.maxDashCharges; i++) {
                    ctx.fillStyle = i < this.dashCharges ? '#3B82F6' : '#333';
                    ctx.fillRect((-10) + (i * 8), -20, 6, 6);
                }
                ctx.restore();
            }
        }

        class Bullet {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.radius = 4;
                this.speed = 12;
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
                this.active = true;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) this.active = false;
                if (frameCount % 4 === 0) particles.push(new Particle(this.x, this.y, '#fff', 2));
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                ctx.fillStyle = '#fff';
                ctx.fill();
            }
        }

        class MokaMan {
            constructor() {
                this.x = -100;
                this.y = canvas.height / 2;
                this.size = 80;
                this.baseSpeed = 2;
                this.speed = this.baseSpeed;
                this.angle = 0;
                this.phase = 'chase'; 
                this.phaseTimer = 0;
                this.spinAngle = 0;
                
                // Boss Stats
                this.rageLevel = 0;
                this.maxHp = 100;
                this.hp = this.maxHp;
                
                this.stunTimer = 0;
                this.fartTimer = 300;
                this.ammoTimer = 600; 
                this.hitFlashTimer = 0;
            }

            takeDamage(amount) {
                if (this.phase === 'rain-pour' || gameMode === 'CLASSIC') return; 
                this.hp -= amount;
                this.hitFlashTimer = 3;
                
                const pct = Math.max(0, (this.hp / this.maxHp) * 100);
                bossHpBar.style.width = `${pct}%`;

                if (this.hp <= 0) {
                    this.levelUp();
                }
            }

            levelUp() {
                this.rageLevel++;
                player.addLife();
                floatingTexts.push(new FloatingText(this.x, this.y - 80, "RAGE UP!", "#ff0000"));
                createParticles(this.x, this.y, '#ff0000', 50);
                
                this.maxHp = 100 + (this.rageLevel * 50);
                this.hp = this.maxHp;
                this.baseSpeed += 0.5;
                
                bossHpBar.style.width = '100%';
                rageLevelDisplay.innerText = this.rageLevel + 1;
                
                projectiles = [];
                this.stunTimer = 60;
            }

            stun(duration) {
                this.stunTimer = duration;
                floatingTexts.push(new FloatingText(this.x, this.y - 50, "STUNNED!", "#FCD34D"));
            }

            dropBuff(type) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 60;
                const ax = this.x + Math.cos(angle) * dist;
                const ay = this.y + Math.sin(angle) * dist;
                const safeX = Math.max(50, Math.min(canvas.width-50, ax));
                const safeY = Math.max(50, Math.min(canvas.height-50, ay));
                
                buffs.push(new Buff(safeX, safeY, type));
                createParticles(safeX, safeY, '#FFD700', 10);
            }

            update(player) {
                if (this.hitFlashTimer > 0) this.hitFlashTimer--;
                
                if (this.stunTimer > 0) {
                    this.stunTimer--;
                    this.x += (Math.random()-0.5)*2; 
                    this.y += (Math.random()-0.5)*2;
                    return;
                }

                this.fartTimer--;
                if (this.fartTimer <= 0) {
                    this.fartTimer = Math.random() * 400 + 400;
                    const type = gameMode === 'BOSS' && Math.random() < 0.2 ? 'LASER' : (['SPEED', 'DASH', 'STUN'][Math.floor(Math.random()*3)]);
                    this.dropBuff(type);
                }

                if (gameMode === 'BOSS') {
                    this.ammoTimer--;
                    if (this.ammoTimer <= 0) {
                        this.dropBuff('AMMO');
                        this.ammoTimer = Math.random() * 800 + 600; 
                    }
                }

                // AI Stats
                if (gameMode === 'BOSS') {
                    this.speed = Math.min(this.baseSpeed + (score / 200), player.baseSpeed * 1.5);
                } else {
                    // Classic: Scale speed purely on score (Time)
                    this.speed = Math.min(2 + (score / 50), 9);
                }
                
                const canCharge = this.rageLevel >= 1 || (gameMode === 'CLASSIC' && score > 300);
                const canSpin = this.rageLevel >= 2 || (gameMode === 'CLASSIC' && score > 600);
                const canRain = this.rageLevel >= 3 || (gameMode === 'CLASSIC' && score > 900);

                const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x);
                this.phaseTimer++;

                if (this.phase === 'chase') {
                    this.angle = angleToPlayer;
                    this.x += Math.cos(this.angle) * this.speed;
                    this.y += Math.sin(this.angle) * this.speed;

                    // Classic mode increases action chance by score, Boss by Rage
                    let actionChance = gameMode === 'BOSS' ? 0.02 + (this.rageLevel * 0.01) : 0.02 + (score * 0.0001);
                    
                    if (this.phaseTimer > 60 && Math.random() < actionChance) {
                        const rand = Math.random();
                        if (canRain && rand < 0.2) {
                            this.phase = 'rain-ascend'; this.phaseTimer = 0;
                            floatingTexts.push(new FloatingText(this.x, this.y - 60, "ESPRESSO RAIN!", "#5D4037"));
                        } else if (canSpin && rand < 0.4) {
                            this.phase = 'spin-charge'; this.phaseTimer = 0;
                            floatingTexts.push(new FloatingText(this.x, this.y - 60, "SPIN!", "#FFF"));
                        } else if (canCharge && rand < 0.7) {
                            this.phase = 'charge'; this.phaseTimer = 0;
                            createParticles(this.x, this.y, 'orange', 10);
                        } else {
                            if ((this.rageLevel > 0 || score > 500) && Math.random() < 0.5) this.tripleShoot(player);
                            else this.shoot(player);
                        }
                    }

                } else if (this.phase === 'charge') {
                    if (this.phaseTimer < 40) { // Warning
                        this.angle = angleToPlayer;
                        this.x += (Math.random()-0.5)*4; this.y += (Math.random()-0.5)*4;
                    } else if (this.phaseTimer < 70) { // Dash
                        const dashSpd = (this.speed * 4);
                        this.x += Math.cos(this.angle) * dashSpd;
                        this.y += Math.sin(this.angle) * dashSpd;
                    } else {
                        this.phase = 'chase'; this.phaseTimer = 0;
                    }

                } else if (this.phase === 'spin-charge') {
                    this.spinAngle += 0.5;
                    if (this.phaseTimer > 40) this.phase = 'spin-fire';

                } else if (this.phase === 'spin-fire') {
                    this.spinAttack();
                    this.phase = 'chase'; this.phaseTimer = 0; this.spinAngle = 0;

                } else if (this.phase === 'rain-ascend') {
                    this.y -= 10;
                    if (this.y < -150) { this.phase = 'rain-pour'; this.phaseTimer = 0; }

                } else if (this.phase === 'rain-pour') {
                    const freq = Math.max(1, 10 - this.rageLevel);
                    if (frameCount % freq === 0) {
                        const dropX = Math.random() * canvas.width;
                        const dropSpeed = 10 + (this.rageLevel * 2);
                        projectiles.push(new Projectile(dropX, -20, Math.PI/2, dropSpeed));
                    }
                    if (this.phaseTimer > 180) this.phase = 'rain-descend';

                } else if (this.phase === 'rain-descend') {
                    this.y += 10;
                    if (this.x < player.x) this.x += 2; else this.x -= 2;
                    if (this.y > canvas.height/4) {
                        this.phase = 'chase'; this.phaseTimer = 0;
                        createParticles(this.x, this.y, '#D7CCC8', 20);
                    }
                }
            }

            shoot(player) {
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                projectiles.push(new Projectile(this.x, this.y, angle, 8 + this.rageLevel));
            }
            tripleShoot(player) {
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                const spd = 7 + this.rageLevel;
                projectiles.push(new Projectile(this.x, this.y, angle, spd));
                projectiles.push(new Projectile(this.x, this.y, angle-0.4, spd));
                projectiles.push(new Projectile(this.x, this.y, angle+0.4, spd));
            }
            spinAttack() {
                const count = 12 + (this.rageLevel * 2);
                const spd = 6 + this.rageLevel;
                for(let i=0; i<count; i++) {
                    const angle = (Math.PI*2/count)*i;
                    projectiles.push(new Projectile(this.x, this.y, angle, spd));
                }
            }

            draw() {
                if (this.phase === 'rain-pour') return;

                ctx.save();
                ctx.translate(this.x, this.y);
                
                if (this.phase === 'spin-charge') ctx.rotate(this.spinAngle);
                else if (this.stunTimer > 0) ctx.rotate((Math.random()-0.5)*0.1);
                else {
                    const tilt = Math.max(-0.2, Math.min(0.2, Math.cos(this.angle)));
                    ctx.rotate(tilt);
                }

                const scale = 1.2;
                ctx.scale(scale, scale);
                
                const rOffset = Math.min(255, this.rageLevel * 40);
                
                if (this.hitFlashTimer > 0) {
                    ctx.fillStyle = '#fff';
                    ctx.beginPath(); ctx.arc(0,0, 40, 0, Math.PI*2); ctx.fill();
                    ctx.restore();
                    return;
                }

                // Cape
                ctx.fillStyle = '#3E2723';
                ctx.beginPath();
                ctx.moveTo(-20, -40); ctx.lineTo(20, -40); ctx.lineTo(30, 60); ctx.lineTo(-30, 60);
                ctx.fill();

                // Body
                const grad = ctx.createLinearGradient(-30, -50, 30, 50);
                grad.addColorStop(0, `rgb(${141+rOffset}, 110, 99)`);
                grad.addColorStop(0.5, `rgb(${215+rOffset}, 204, 200)`); 
                grad.addColorStop(1, `rgb(${93+rOffset}, 64, 55)`);
                ctx.fillStyle = grad;
                
                ctx.beginPath();
                ctx.moveTo(-25, -30); ctx.lineTo(25, -30); ctx.lineTo(20, 40); ctx.lineTo(-20, 40);
                ctx.closePath(); ctx.fill();
                ctx.lineWidth = 2; ctx.strokeStyle = '#3E2723'; ctx.stroke();

                // Head
                ctx.save(); ctx.translate(0, -50);
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.moveTo(-20, -25); ctx.lineTo(20, -25); ctx.lineTo(25, 30); ctx.lineTo(-25, 30); ctx.closePath();
                ctx.fill(); ctx.stroke();
                
                ctx.fillStyle = this.stunTimer > 0 ? '#60A5FA' : (this.rageLevel > 2 ? '#ff0000' : '#FFECB3');
                ctx.beginPath(); ctx.arc(-10, 0, 3 + (this.rageLevel), 0, Math.PI*2); ctx.arc(10, 0, 3 + (this.rageLevel), 0, Math.PI*2); ctx.fill();
                ctx.restore();

                // Arms
                ctx.fillStyle = grad;
                if (this.phase === 'spin-charge') {
                     ctx.beginPath(); ctx.arc(-40, -10, 12, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                     ctx.beginPath(); ctx.arc(40, -10, 12, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                } else {
                    const armSwing = Math.sin(Date.now() / 100) * 10;
                    ctx.beginPath(); ctx.arc(-35, -20 + armSwing, 12, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                    ctx.beginPath(); ctx.arc(35, -20 - armSwing, 12, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                }

                ctx.restore();
            }
        }

        class Projectile {
            constructor(x, y, angle, speed) {
                this.x = x; this.y = y; this.radius = 6;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.active = true;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                if(this.x < -50 || this.x > canvas.width+50 || this.y < -50 || this.y > canvas.height+50) this.active = false;
                if(Math.random()<0.3) particles.push(new Particle(this.x, this.y, '#6D4C41', 2));
            }
            draw() {
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                ctx.fillStyle = '#3e2723'; ctx.fill(); ctx.strokeStyle = '#fff'; ctx.stroke();
            }
        }

        class Buff {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type; this.radius = 15; this.life = 600;
                if (type==='SPEED') { this.color='#4ADE80'; this.label='âš¡'; }
                else if (type==='DASH') { this.color='#60A5FA'; this.label='â©'; }
                else if (type==='STUN') { this.color='#FCD34D'; this.label='ðŸ’«'; }
                else if (type==='AMMO') { this.color='#FFD700'; this.label='ðŸ“¦'; }
                else if (type==='LASER') { this.color='#d946ef'; this.label='âš›'; }
            }
            draw() {
                const pulse = Math.sin(Date.now()/200)*3;
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.globalAlpha = 0.6+(Math.sin(Date.now()/100)*0.2);
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(0,0,this.radius+pulse,0,Math.PI*2); ctx.fill();
                ctx.globalAlpha=1; ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.stroke();
                ctx.fillStyle='#fff'; ctx.font='16px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(this.label,0,1);
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color, sizeBase) {
                this.x = x; this.y = y; this.size = Math.random()*sizeBase+1; this.color = color;
                this.vx = (Math.random()-0.5)*2; this.vy = (Math.random()-0.5)*2; this.life = 1.0;
            }
            update() { this.x += this.vx; this.y += this.vy; this.life -= 0.05; }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
            }
        }

        class FloatingText {
            constructor(x, y, text, color) {
                this.x = x; this.y = y; this.text = text; this.color = color; this.life = 60; this.dy = -1;
            }
            update() { this.y += this.dy; this.life--; }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life/20);
                ctx.fillStyle = this.color; ctx.font = 'bold 20px Courier New';
                ctx.strokeStyle = 'black'; ctx.lineWidth = 3;
                ctx.strokeText(this.text, this.x, this.y); ctx.fillText(this.text, this.x, this.y);
                ctx.globalAlpha = 1;
            }
        }

        function createParticles(x, y, color, count) {
            for(let i=0; i<count; i++) particles.push(new Particle(x, y, color, 5));
        }

        function updateUI() {
            dashUi.innerHTML = '';
            for(let i=0; i < player.maxDashCharges; i++) {
                const pip = document.createElement('div');
                pip.className = `w-3 h-3 rounded-full ${i < player.dashCharges ? 'bg-blue-500 shadow-[0_0_8px_rgba(59,130,246,0.8)]' : 'bg-gray-700'}`;
                dashUi.appendChild(pip);
            }
            
            let hearts = '';
            for(let i=0; i<player.lives; i++) hearts += 'â™¥';
            livesUi.innerText = hearts;
            ammoUi.innerText = player.ammo;
            scoreDisplay.innerText = score;

            // Laser UI
            if (player.hasLaser) {
                laserUiContainer.classList.remove('hidden');
                laserUiContainer.classList.add('flex');
                laserBar.style.width = `${(player.laserTimer / player.laserMaxTime) * 100}%`;
            } else {
                laserUiContainer.classList.add('hidden');
                laserUiContainer.classList.remove('flex');
            }
        }

        // Main Loop
        let player, mokaMan, gameLoopId;

        function initGame(mode) {
            gameMode = mode;
            player = new Player();
            mokaMan = new MokaMan();
            score = 0;
            frameCount = 0;
            particles = [];
            projectiles = [];
            bullets = [];
            buffs = [];
            floatingTexts = [];
            
            // Adjust setup for Classic Mode
            if (gameMode === 'CLASSIC') {
                bossUi.classList.add('hidden');
                livesContainer.classList.add('hidden');
                ammoContainer.classList.add('hidden');
                controlsHint.innerText = "WASD/ARROWS to Move â€¢ SPACE to Dash â€¢ SURVIVE!";
                mobileShootBtn.classList.add('hidden');
                mobileDashBtn.style.width = '100%';
            } else {
                bossUi.classList.remove('hidden');
                bossHpBar.style.width = '100%';
                rageLevelDisplay.innerText = '0';
                livesContainer.classList.remove('hidden');
                ammoContainer.classList.remove('hidden');
                controlsHint.innerText = "WASD/ARROWS to Move â€¢ CLICK to Shoot â€¢ SPACE to Dash";
                mobileShootBtn.classList.remove('hidden');
                mobileDashBtn.style.width = '50%';
            }
            
            mokaMan.x = -100;
            mokaMan.y = canvas.height / 2;
            updateUI();
        }

        function checkCollisions() {
            // Player vs Boss Body
            const distBoss = Math.hypot(player.x - mokaMan.x, player.y - mokaMan.y);
            if (distBoss < player.size + mokaMan.size * 0.5 && mokaMan.stunTimer <= 0) {
                 if(player.takeDamage()) gameOver();
            }
            
            // Player vs Enemy Projectiles
            for(let i=projectiles.length-1; i>=0; i--) {
                const p = projectiles[i];
                if (Math.hypot(player.x - p.x, player.y - p.y) < player.size + p.radius) {
                    if(player.takeDamage()) gameOver();
                    projectiles.splice(i,1); 
                }
            }

            // Player vs Buffs
            for (let i = buffs.length - 1; i >= 0; i--) {
                const b = buffs[i];
                if (Math.hypot(player.x - b.x, player.y - b.y) < player.size + b.radius) {
                    if (b.type === 'SPEED') { player.applySpeedBuff(300); floatingTexts.push(new FloatingText(player.x, player.y, "SPEED UP!", "#4ADE80")); }
                    else if (b.type === 'DASH') { player.dashCharges = Math.min(player.maxDashCharges+2, player.dashCharges+1); floatingTexts.push(new FloatingText(player.x, player.y, "+1 DASH", "#60A5FA")); }
                    else if (b.type === 'STUN') { mokaMan.stun(180); floatingTexts.push(new FloatingText(player.x, player.y, "STUNNED!", "#FCD34D")); }
                    else if (b.type === 'AMMO') { 
                        const amount = Math.floor(Math.random() * 11) + 60; 
                        player.addAmmo(amount); 
                    }
                    else if (b.type === 'LASER') {
                        player.activateLaser();
                    }
                    buffs.splice(i, 1);
                    updateUI();
                }
            }

            // Bullets vs Boss (Only Boss Mode)
            if (gameMode === 'BOSS') {
                for(let i=bullets.length-1; i>=0; i--) {
                    const b = bullets[i];
                    const dist = Math.hypot(b.x - mokaMan.x, b.y - mokaMan.y);
                    if (dist < mokaMan.size * 0.6) { 
                        mokaMan.takeDamage(5); 
                        createParticles(b.x, b.y, '#fff', 5);
                        bullets.splice(i, 1);
                    }
                }
            }
        }

        function gameOver() {
            gameRunning = false;
            cancelAnimationFrame(gameLoopId);
            finalScoreDisplay.innerText = score;
            finalRageDisplay.innerText = mokaMan.rageLevel;
            
            if (gameMode === 'CLASSIC') {
                bossStatsEnd.classList.add('hidden');
                document.getElementById('death-msg').innerText = "You survived for " + score + " ticks!";
            } else {
                bossStatsEnd.classList.remove('hidden');
                document.getElementById('death-msg').innerText = "Moka Man caught you.";
            }

            bossUi.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');
        }

        function update() {
            if (!gameRunning) return;

            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = '#2a2a2a'; ctx.lineWidth = 1;
            ctx.beginPath();
            for(let x=0; x<=canvas.width; x+=50) { ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); }
            for(let y=0; y<=canvas.height; y+=50) { ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); }
            ctx.stroke();

            player.update();
            mokaMan.update(player);
            
            [projectiles, bullets, buffs, particles, floatingTexts].forEach(arr => {
                for(let i=arr.length-1; i>=0; i--) {
                    if(arr[i].update) arr[i].update();
                    if(arr[i].life <= 0 || arr[i].active === false) arr.splice(i, 1);
                }
            });

            checkCollisions();

            buffs.forEach(b => b.draw());
            particles.forEach(p => p.draw());
            projectiles.forEach(p => p.draw());
            bullets.forEach(b => b.draw());
            mokaMan.draw();
            player.draw();
            floatingTexts.forEach(t => t.draw());

            // Score logic
            if (frameCount % 60 === 0 && frameCount > 0) {
                score++;
                updateUI();
            }
            frameCount++;
            gameLoopId = requestAnimationFrame(update);
        }

        // --- MENU EVENTS ---
        
        btnClassic.addEventListener('click', () => {
            startScreen.classList.add('hidden');
            gameRunning = true;
            initGame('CLASSIC');
            update();
        });

        btnBoss.addEventListener('click', () => {
            startScreen.classList.add('hidden');
            gameRunning = true;
            initGame('BOSS');
            update();
        });

        restartBtn.addEventListener('click', () => {
            gameOverScreen.classList.add('hidden');
            startScreen.classList.remove('hidden'); // Go back to mode selection
        });
    </script>
</body>
</html>
